name: OpenAI Codex Agent

# Dieser Workflow reagiert auf @codex Mentions in PR- und Issue-Kommentaren
# und f√ºhrt verschiedene Code-Aufgaben mit OpenAI Codex aus

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      task_type:
        description: 'Art der Aufgabe'
        required: true
        type: choice
        options:
          - review
          - fix
          - explain
          - test
        default: 'review'
      target_ref:
        description: 'Branch oder PR-Nummer'
        required: true
        type: string
      agent:
        description: 'Agent ausw√§hlen'
        required: false
        type: choice
        options:
          - codex
          - copilot
          - both
        default: 'codex'

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write
  statuses: write

jobs:
  # Job pr√ºft ob @codex erw√§hnt wurde
  check-mention:
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '@codex')
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      task_type: ${{ steps.parse.outputs.task_type }}
    
    steps:
      - name: Check if comment mentions @codex
        id: check
        run: |
          if [[ "${{ github.event.comment.body }}" == *"@codex"* ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Parse task type from comment
        id: parse
        run: |
          COMMENT="${{ github.event.comment.body }}"
          TASK_TYPE="review"
          
          if [[ "$COMMENT" == *"fix"* ]] || [[ "$COMMENT" == *"beheb"* ]]; then
            TASK_TYPE="fix"
          elif [[ "$COMMENT" == *"explain"* ]] || [[ "$COMMENT" == *"erkl√§re"* ]]; then
            TASK_TYPE="explain"
          elif [[ "$COMMENT" == *"test"* ]]; then
            TASK_TYPE="test"
          elif [[ "$COMMENT" == *"review"* ]]; then
            TASK_TYPE="review"
          fi
          
          echo "task_type=$TASK_TYPE" >> $GITHUB_OUTPUT
          echo "Erkannte Aufgabe: $TASK_TYPE"

  # Job f√ºr Code-Review mit Codex
  codex-review:
    runs-on: ubuntu-latest
    needs: check-mention
    if: |
      (github.event_name == 'issue_comment' && needs.check-mention.outputs.should_run == 'true' && needs.check-mention.outputs.task_type == 'review') ||
      (github.event_name == 'workflow_dispatch' && inputs.task_type == 'review' && (inputs.agent == 'codex' || inputs.agent == 'both'))
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get PR Details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;
            if (context.eventName === 'issue_comment') {
              prNumber = context.issue.number;
            } else {
              prNumber = parseInt(context.payload.inputs.target_ref);
            }
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('head_sha', pr.data.head.sha);
            core.setOutput('base_sha', pr.data.base.sha);
            return pr.data;
      
      - name: Get PR Diff
        id: diff
        run: |
          git fetch origin ${{ steps.pr.outputs.head_sha }}
          git fetch origin ${{ steps.pr.outputs.base_sha }}
          
          DIFF=$(git diff ${{ steps.pr.outputs.base_sha }}..${{ steps.pr.outputs.head_sha }})
          
          # Speichere Diff in Datei f√ºr API-Call
          echo "$DIFF" > /tmp/pr_diff.txt
          
          # Begrenze auf erste 8000 Zeichen f√ºr API
          DIFF_PREVIEW=$(echo "$DIFF" | head -c 8000)
          echo "diff_preview<<EOF" >> $GITHUB_OUTPUT
          echo "$DIFF_PREVIEW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Call OpenAI Codex API for Review
        id: codex
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Erstelle Review-Prompt
          PROMPT="Du bist ein erfahrener Code-Reviewer. Analysiere die folgenden Code-√Ñnderungen und gib konstruktives Feedback auf Deutsch:

          ## Code-√Ñnderungen:
          \`\`\`diff
          ${{ steps.diff.outputs.diff_preview }}
          \`\`\`
          
          Bitte pr√ºfe auf:
          - Potenzielle Bugs
          - Code-Qualit√§t und Best Practices
          - Sicherheitsprobleme
          - Performance-Aspekte
          - Kotlin/Android Best Practices
          
          Gib dein Feedback strukturiert zur√ºck."
          
          # API Call an OpenAI
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{
                \"role\": \"system\",
                \"content\": \"Du bist ein erfahrener Software-Engineer und Code-Reviewer, spezialisiert auf Kotlin und Android-Entwicklung.\"
              }, {
                \"role\": \"user\",
                \"content\": $(echo "$PROMPT" | jq -Rs .)
              }],
              \"temperature\": 0.3,
              \"max_tokens\": 2000
            }")
          
          # Validiere API Response und extrahiere Review-Text
          if echo "$RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            REVIEW_TEXT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          else
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // "Unbekannter Fehler"')
            REVIEW_TEXT="‚ö†Ô∏è Fehler beim Abrufen des Reviews von OpenAI API: $ERROR_MSG"
          fi
          
          echo "review_text<<EOF" >> $GITHUB_OUTPUT
          echo "$REVIEW_TEXT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Post Review as Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const reviewText = `## ü§ñ OpenAI Codex Code-Review
            
            ${{ steps.codex.outputs.review_text }}
            
            ---
            *Automatisch erstellt durch OpenAI Codex Agent*
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr.outputs.pr_number }},
              body: reviewText
            });

  # Job f√ºr automatische Bug-Fixes mit Codex
  codex-fix:
    runs-on: ubuntu-latest
    needs: check-mention
    if: |
      (github.event_name == 'issue_comment' && needs.check-mention.outputs.should_run == 'true' && needs.check-mention.outputs.task_type == 'fix') ||
      (github.event_name == 'workflow_dispatch' && inputs.task_type == 'fix' && (inputs.agent == 'codex' || inputs.agent == 'both'))
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
      
      - name: Get PR Details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;
            if (context.eventName === 'issue_comment') {
              prNumber = context.issue.number;
            } else {
              prNumber = parseInt(context.payload.inputs.target_ref);
            }
            
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('head_ref', pr.data.head.ref);
            return pr.data;
      
      - name: Checkout PR Branch
        run: |
          git fetch origin ${{ steps.pr.outputs.head_ref }}
          git checkout ${{ steps.pr.outputs.head_ref }}
      
      - name: Analyze Issues with Codex
        id: analyze
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Sammle Build-/Test-Fehler
          ./gradlew build --no-daemon --stacktrace > /tmp/build_output.txt 2>&1 || true
          
          # Sanitize build output - entferne potenzielle Secrets
          BUILD_OUTPUT=$(cat /tmp/build_output.txt | tail -n 100 | \
            sed 's/password[=:][^ ]*/password=***/gi' | \
            sed 's/token[=:][^ ]*/token=***/gi' | \
            sed 's/key[=:][^ ]*/key=***/gi' | \
            sed 's|https://[^/]*:[^@]*@|https://***:***@|g')
          
          # Prompt f√ºr Codex
          PROMPT="Analysiere die folgenden Build-/Test-Fehler und schlage konkrete Fixes vor:

          \`\`\`
          $BUILD_OUTPUT
          \`\`\`
          
          Gib die Fixes im folgenden JSON-Format zur√ºck:
          {
            \"fixes\": [
              {
                \"file\": \"pfad/zur/datei.kt\",
                \"description\": \"Beschreibung des Problems\",
                \"solution\": \"Konkrete L√∂sung\"
              }
            ]
          }"
          
          # API Call
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{
                \"role\": \"system\",
                \"content\": \"Du bist ein Experte f√ºr Kotlin und Android-Entwicklung. Analysiere Fehler und schlage pr√§zise Fixes vor.\"
              }, {
                \"role\": \"user\",
                \"content\": $(echo "$PROMPT" | jq -Rs .)
              }],
              \"temperature\": 0.2,
              \"max_tokens\": 2000
            }")
          
          # Validiere API Response und extrahiere Fixes
          if echo "$RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            FIXES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          else
            FIXES="Fehler beim Abrufen der Fixes von OpenAI API. Response: $(echo "$RESPONSE" | jq -r '.error.message // "Unbekannter Fehler"')"
          fi
          
          echo "fixes<<EOF" >> $GITHUB_OUTPUT
          echo "$FIXES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Post Fix Suggestions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fixes = `## üîß OpenAI Codex Fix-Vorschl√§ge
            
            ${{ steps.analyze.outputs.fixes }}
            
            ---
            *Automatisch erstellt durch OpenAI Codex Agent*
            
            **Hinweis:** Diese Vorschl√§ge wurden automatisch generiert. Bitte pr√ºfe sie sorgf√§ltig, bevor du sie anwendest.
            **Keine automatischen Commits** wurden durchgef√ºhrt - alle √Ñnderungen m√ºssen manuell √ºberpr√ºft und angewendet werden.
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr.outputs.pr_number }},
              body: fixes
            });

  # Job f√ºr Code-Erkl√§rungen mit Codex
  codex-explain:
    runs-on: ubuntu-latest
    needs: check-mention
    if: |
      (github.event_name == 'issue_comment' && needs.check-mention.outputs.should_run == 'true' && needs.check-mention.outputs.task_type == 'explain') ||
      (github.event_name == 'workflow_dispatch' && inputs.task_type == 'explain' && (inputs.agent == 'codex' || inputs.agent == 'both'))
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Get PR Context
        id: context
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;
            if (context.eventName === 'issue_comment') {
              prNumber = context.issue.number;
            } else {
              prNumber = parseInt(context.payload.inputs.target_ref);
            }
            
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            core.setOutput('pr_number', prNumber);
            return files.data;
      
      - name: Generate Explanation with Codex
        id: explain
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          PROMPT="Erkl√§re die √Ñnderungen in diesem Pull Request auf Deutsch. Gehe auf folgende Aspekte ein:
          - Was wurde ge√§ndert?
          - Warum sind diese √Ñnderungen wichtig?
          - Welche Auswirkungen haben sie?
          - Gibt es potenzielle Risiken?
          
          Erkl√§re es so, dass es auch jemand ohne tiefe technische Kenntnisse verstehen kann."
          
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{
                \"role\": \"system\",
                \"content\": \"Du bist ein technischer Kommunikator, der komplexe Code-√Ñnderungen verst√§ndlich erkl√§ren kann.\"
              }, {
                \"role\": \"user\",
                \"content\": $(echo "$PROMPT" | jq -Rs .)
              }],
              \"temperature\": 0.5,
              \"max_tokens\": 1500
            }")
          
          EXPLANATION=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          echo "explanation<<EOF" >> $GITHUB_OUTPUT
          echo "$EXPLANATION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Post Explanation
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const explanation = `## üìö OpenAI Codex Code-Erkl√§rung
            
            ${{ steps.explain.outputs.explanation }}
            
            ---
            *Automatisch erstellt durch OpenAI Codex Agent*
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.context.outputs.pr_number }},
              body: explanation
            });

  # Job f√ºr Test-Generierung mit Codex
  codex-test:
    runs-on: ubuntu-latest
    needs: check-mention
    if: |
      (github.event_name == 'issue_comment' && needs.check-mention.outputs.should_run == 'true' && needs.check-mention.outputs.task_type == 'test') ||
      (github.event_name == 'workflow_dispatch' && inputs.task_type == 'test' && (inputs.agent == 'codex' || inputs.agent == 'both'))
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Analyze Code for Test Generation
        id: analyze
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Finde Kotlin-Dateien ohne Tests
          FILES_WITHOUT_TESTS=$(find shared androidApp -name "*.kt" -type f | head -5)
          
          PROMPT="Analysiere die folgenden Kotlin-Dateien und generiere Unit-Tests mit JUnit/Kotest:
          
          Erstelle Tests f√ºr:
          - Happy Path Scenarios
          - Edge Cases
          - Error Handling
          
          Nutze Kotlin Best Practices und idiomatischen Code."
          
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{
                \"role\": \"system\",
                \"content\": \"Du bist ein Experte f√ºr Kotlin Test-Entwicklung mit JUnit und Kotest.\"
              }, {
                \"role\": \"user\",
                \"content\": $(echo "$PROMPT" | jq -Rs .)
              }],
              \"temperature\": 0.3,
              \"max_tokens\": 2000
            }")
          
          TESTS=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          echo "tests<<EOF" >> $GITHUB_OUTPUT
          echo "$TESTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Post Test Suggestions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let prNumber;
            if (context.eventName === 'issue_comment') {
              prNumber = context.issue.number;
            } else {
              prNumber = parseInt(context.payload.inputs.target_ref);
            }
            
            const tests = `## üß™ OpenAI Codex Test-Vorschl√§ge
            
            ${{ steps.analyze.outputs.tests }}
            
            ---
            *Automatisch erstellt durch OpenAI Codex Agent*
            `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: tests
            });
