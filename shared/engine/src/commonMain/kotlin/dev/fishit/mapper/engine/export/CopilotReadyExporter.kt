package dev.fishit.mapper.engine.export

import dev.fishit.mapper.engine.api.*

/**
 * Generiert Copilot-optimierte Markdown-Dokumentation.
 *
 * Dieses Format ist speziell designed fÃ¼r GitHub Copilot:
 * - Strukturierte Endpoint-Dokumentation
 * - Code-Beispiele die Copilot versteht
 * - TODO-Listen fÃ¼r gezielte Code-Generierung
 *
 * ## Verwendung
 * ```kotlin
 * val generator = CopilotReadyExporter()
 * val markdown = generator.export(blueprint)
 * // Speichern als API_ANALYSIS.md
 * // Ã–ffnen in Codespace â†’ Copilot kann direkt damit arbeiten
 * ```
 */
class CopilotReadyExporter {

    /**
     * Exportiert einen Blueprint als Copilot-optimiertes Markdown.
     */
    fun export(blueprint: ApiBlueprint): String {
        return buildString {
            // Header
            appendLine("# API Analysis: ${blueprint.name}")
            appendLine()
            appendLine("> Auto-generated by FishIT-Mapper")
            appendLine("> Base URL: `${blueprint.baseUrl}`")
            appendLine("> Endpoints: ${blueprint.endpoints.size} | Auth Patterns: ${blueprint.authPatterns.size}")
            appendLine()

            // Quick Stats
            appendLine("## ðŸ“Š Overview")
            appendLine()
            appendLine("| Metric | Value |")
            appendLine("|--------|-------|")
            appendLine("| Total Endpoints | ${blueprint.endpoints.size} |")
            appendLine("| Total Exchanges Analyzed | ${blueprint.metadata.totalExchangesAnalyzed} |")
            appendLine("| Auth Patterns Detected | ${blueprint.authPatterns.size} |")
            appendLine("| API Flows Detected | ${blueprint.flows.size} |")
            appendLine()

            // Auth Patterns
            if (blueprint.authPatterns.isNotEmpty()) {
                appendLine("## ðŸ” Authentication")
                appendLine()
                for (pattern in blueprint.authPatterns) {
                    appendLine(formatAuthPattern(pattern))
                }
                appendLine()
            }

            // Endpoints
            appendLine("## ðŸ“¡ Endpoints")
            appendLine()

            // Gruppiere nach Tags/Pfad-Prefix
            val groupedEndpoints = blueprint.endpoints.groupBy { endpoint ->
                endpoint.tags.firstOrNull() ?: endpoint.pathTemplate.split("/").getOrNull(2) ?: "other"
            }

            for ((group, endpoints) in groupedEndpoints) {
                appendLine("### ${group.replaceFirstChar { it.uppercase() }}")
                appendLine()

                for (endpoint in endpoints) {
                    appendLine(formatEndpoint(endpoint, blueprint.baseUrl))
                    appendLine()
                }
            }

            // Flows
            if (blueprint.flows.isNotEmpty()) {
                appendLine("## ðŸ”„ API Flows")
                appendLine()
                for (flow in blueprint.flows) {
                    appendLine(formatFlow(flow, blueprint.endpoints))
                    appendLine()
                }
            }

            // Copilot Instructions
            appendLine("---")
            appendLine()
            appendLine("## ðŸ¤– Instructions for GitHub Copilot")
            appendLine()
            appendLine("Use the following prompts to generate code from this analysis:")
            appendLine()
            appendLine("### Generate Kotlin Data Classes")
            appendLine("```")
            appendLine("@workspace Generate Kotlin @Serializable data classes for all response types in this API")
            appendLine("```")
            appendLine()
            appendLine("### Generate Ktor Client")
            appendLine("```")
            appendLine("@workspace Create a Ktor HttpClient wrapper with functions for each endpoint")
            appendLine("```")
            appendLine()
            appendLine("### Generate Tests")
            appendLine("```")
            appendLine("@workspace Generate unit tests for the API client using MockEngine")
            appendLine("```")
            appendLine()

            // TODO Checklist
            appendLine("## âœ… Code Generation Checklist")
            appendLine()
            appendLine("- [ ] Generate data classes from response examples")
            appendLine("- [ ] Create API client interface")
            appendLine("- [ ] Implement authentication handling")
            appendLine("- [ ] Add error handling and retries")
            appendLine("- [ ] Generate request builders for complex endpoints")
            appendLine("- [ ] Create integration tests")
            appendLine()

            // Raw Data Reference
            appendLine("## ðŸ“ Related Files")
            appendLine()
            appendLine("- `traffic.har` - Raw HTTP traffic (HAR format)")
            appendLine("- `api-stubs.kt` - Generated Kotlin stubs")
            appendLine("- `analysis.json` - Machine-readable analysis")
        }
    }

    private fun formatAuthPattern(pattern: AuthPattern): String {
        return when (pattern) {
            is AuthPattern.BearerTokenPattern -> """
                |**Bearer Token Authentication**
                |- Header: `${pattern.headerName}`
                |- Prefix: `${pattern.tokenPrefix}`
                |
                |```http
                |${pattern.headerName}: ${pattern.tokenPrefix}<token>
                |```
            """.trimMargin()

            is AuthPattern.SessionCookiePattern -> """
                |**Session Cookie Authentication**
                |- Cookie: `${pattern.cookieName}`
                |${pattern.domain?.let { "- Domain: `$it`" } ?: ""}
            """.trimMargin()

            is AuthPattern.ApiKeyPattern -> """
                |**API Key Authentication**
                |- Location: ${pattern.location.name}
                |- Parameter: `${pattern.parameterName}`
            """.trimMargin()

            is AuthPattern.BasicAuthPattern -> """
                |**HTTP Basic Authentication**
                |
                |```http
                |Authorization: Basic <base64(username:password)>
                |```
            """.trimMargin()

            is AuthPattern.OAuth2Pattern -> """
                |**OAuth2 Authentication**
                |- Token Endpoint: `${pattern.tokenEndpoint}`
                |- Grant Type: `${pattern.grantType}`
                |${if (pattern.scopes.isNotEmpty()) "- Scopes: `${pattern.scopes.joinToString(", ")}`" else ""}
            """.trimMargin()
        }
    }

    private fun formatEndpoint(endpoint: ApiEndpoint, baseUrl: String): String {
        return buildString {
            // Header mit Method Badge
            val methodEmoji = when (endpoint.method) {
                HttpMethod.GET -> "ðŸŸ¢"
                HttpMethod.POST -> "ðŸŸ¡"
                HttpMethod.PUT -> "ðŸŸ "
                HttpMethod.PATCH -> "ðŸ”µ"
                HttpMethod.DELETE -> "ðŸ”´"
                else -> "âšª"
            }

            appendLine("#### $methodEmoji `${endpoint.method.name}` ${endpoint.pathTemplate}")
            appendLine()

            // Description
            endpoint.metadata.description?.let {
                appendLine("> $it")
                appendLine()
            }

            // Stats
            appendLine("- Observed: ${endpoint.metadata.hitCount}x")
            endpoint.metadata.avgResponseTimeMs?.let {
                appendLine("- Avg Response Time: ${it}ms")
            }
            if (endpoint.authRequired != AuthType.None) {
                appendLine("- Auth: ${endpoint.authRequired.name}")
            }
            appendLine()

            // Parameters
            if (endpoint.pathParameters.isNotEmpty()) {
                appendLine("**Path Parameters:**")
                appendLine()
                appendLine("| Name | Type | Required | Example |")
                appendLine("|------|------|----------|---------|")
                for (param in endpoint.pathParameters) {
                    appendLine("| `${param.name}` | ${param.type.name.lowercase()} | ${if (param.required) "âœ…" else "âŒ"} | ${param.example ?: "-"} |")
                }
                appendLine()
            }

            if (endpoint.queryParameters.isNotEmpty()) {
                appendLine("**Query Parameters:**")
                appendLine()
                appendLine("| Name | Type | Required | Example |")
                appendLine("|------|------|----------|---------|")
                for (param in endpoint.queryParameters) {
                    appendLine("| `${param.name}` | ${param.type.name.lowercase()} | ${if (param.required) "âœ…" else "âŒ"} | ${param.example ?: "-"} |")
                }
                appendLine()
            }

            // Request Body
            endpoint.requestBody?.let { body ->
                appendLine("**Request Body:** `${body.contentType}`")
                appendLine()
                body.examples.firstOrNull()?.let { example ->
                    appendLine("```json")
                    appendLine(formatJson(example.value))
                    appendLine("```")
                    appendLine()
                }
            }

            // Responses
            if (endpoint.responses.isNotEmpty()) {
                appendLine("**Responses:**")
                appendLine()
                for (response in endpoint.responses) {
                    val statusEmoji = when (response.statusCode) {
                        in 200..299 -> "âœ…"
                        in 300..399 -> "â†ªï¸"
                        in 400..499 -> "âš ï¸"
                        in 500..599 -> "âŒ"
                        else -> "â“"
                    }
                    appendLine("$statusEmoji **${response.statusCode}** ${response.description ?: ""}")

                    response.examples.firstOrNull()?.let { example ->
                        appendLine()
                        appendLine("```json")
                        appendLine(formatJson(example.value))
                        appendLine("```")
                    }
                    appendLine()
                }
            }

            // Example HTTP Request
            appendLine("<details>")
            appendLine("<summary>ðŸ“‹ Example HTTP Request</summary>")
            appendLine()
            appendLine("```http")
            appendLine("${endpoint.method.name} ${baseUrl}${formatPathWithExamples(endpoint)} HTTP/1.1")
            for (header in endpoint.headerParameters) {
                appendLine("${header.name}: ${header.example ?: "<value>"}")
            }
            if (endpoint.authRequired != AuthType.None) {
                appendLine("Authorization: Bearer <token>")
            }
            endpoint.requestBody?.let {
                appendLine("Content-Type: ${it.contentType}")
                appendLine()
                it.examples.firstOrNull()?.let { ex ->
                    appendLine(formatJson(ex.value))
                }
            }
            appendLine("```")
            appendLine()
            appendLine("</details>")
        }
    }

    private fun formatFlow(flow: ApiFlow, endpoints: List<ApiEndpoint>): String {
        return buildString {
            appendLine("### ðŸ”— ${flow.name}")
            appendLine()
            flow.description?.let {
                appendLine("> $it")
                appendLine()
            }

            appendLine("**Steps:**")
            appendLine()
            appendLine("```mermaid")
            appendLine("sequenceDiagram")
            appendLine("    participant Client")
            appendLine("    participant API")

            for (step in flow.steps) {
                val endpoint = endpoints.find { it.id == step.endpointId }
                val label = endpoint?.let { "${it.method.name} ${it.pathTemplate}" } ?: step.endpointId

                appendLine("    Client->>API: ${step.order + 1}. $label")
                step.expectedStatus?.let {
                    appendLine("    API-->>Client: $it")
                }
            }

            appendLine("```")
            appendLine()

            // Step Details
            for (step in flow.steps) {
                val endpoint = endpoints.find { it.id == step.endpointId }
                appendLine("${step.order + 1}. **${endpoint?.method?.name ?: "?"} ${endpoint?.pathTemplate ?: step.endpointId}**")
                step.description?.let { appendLine("   - $it") }
                if (step.extractors.isNotEmpty()) {
                    appendLine("   - Extracts: ${step.extractors.joinToString(", ") { it.variableName }}")
                }
            }
        }
    }

    private fun formatPathWithExamples(endpoint: ApiEndpoint): String {
        var path = endpoint.pathTemplate
        for (param in endpoint.pathParameters) {
            val value = param.example ?: "<${param.name}>"
            path = path.replace("{${param.name}}", value)
        }

        if (endpoint.queryParameters.isNotEmpty()) {
            val queryParams = endpoint.queryParameters.mapNotNull { param ->
                param.example?.let { "${param.name}=$it" }
            }
            if (queryParams.isNotEmpty()) {
                path += "?" + queryParams.joinToString("&")
            }
        }

        return path
    }

    private fun formatJson(json: String): String {
        // Versuche JSON zu formatieren, falls nicht schon formatiert
        return try {
            val trimmed = json.trim()
            if (trimmed.length > 500) {
                trimmed.take(500) + "\n// ... truncated"
            } else {
                trimmed
            }
        } catch (e: Exception) {
            json.take(500)
        }
    }
}
